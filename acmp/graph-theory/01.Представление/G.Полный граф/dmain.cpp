#include <iostream>
#include <fstream>
namespace quix { typedef long long llong; typedef long double ldouble; template<typename T> struct Type { typedef T value; }; template<bool Cond, typename T, typename U> struct IF { typedef T value_type; }; template<typename T, typename U> struct IF<false, T, U> { typedef U value_type; };  template<typename F, typename T, typename U> inline auto bcascade(F f, T t, U u) { return f(t, u); } template<typename F, typename T, typename...Args> inline auto bcascade(F f, T t, Args...args) { return f(t, bcascade(f, args...)); } template<typename F, typename T> inline void ucascade(F f, T t) { f(t); return; } template<typename F, typename T, typename...Args> inline void ucascade(F f, T t, Args...args) { f(t); ucascade(f, args...); return; } template<typename F, typename F2, typename T, typename U> inline T dcascade(F f, F2 f2, T t, U u) { return f(f2(t), f2(u)); } template<typename F, typename F2, typename T, typename...Args> inline T dcascade(F f, F2 f2, T t, Args...args) { return f( f2(t), f2(dcascade(f, f2, args...)) ); } } namespace quix {  constexpr ldouble const ALPHA = 0.000001; template<typename T> T abs(T t) { return t < 0 ? -t : t; }  template<typename T> inline T mod(T a, T b) { return (b + a%b) % b; }  template<typename T> T gcd(T a, T b) { a = abs(a); b = abs(b); while(a) { b %= a; std::swap(a, b); } return b; } template<typename T> inline T lcm(T a, T b) { return abs(a)/gcd<T>(a, b)*abs(b); } template<typename T> T exgcd(T a, T b, T &x, T &y) { if(a == 0) { x = 0, y = 1; return b; } T xx, yy, g; g = exgcd(b%a, a, xx, yy); x = yy - xx*(b/a); y = xx; return g; } template<typename T> inline T div(T a, T b, T m) { T nul; exgcd(b, m, b, nul); return mod(a*b, m); }  template<typename T, typename...Args> void reduce(T *t, Args*...args) { T g = bcascade(gcd<T>, *t, *args...); ucascade( [g](T *t) { *t /= g; }, t, args... ); } template< typename Iterator, typename T = typename std::remove_reference< decltype(*Iterator()) >::type > T summation(Iterator b, Iterator e) { T res = T(); while(b != e) { res = res + *b; ++b; } return res; } template< typename Iterator, typename T = typename std::remove_reference< decltype(*Iterator()) >::type > void summation(Iterator b, Iterator e, T &res) { while(b != e) { res = res + *b; ++b; } return; } }  
#include <cstring>
struct AdjacMatrix { int n; char *d; inline AdjacMatrix &init() { d = new char[n*n]; return *this; } inline AdjacMatrix &init(int newn) { n = newn; d = new char[n*n]; return *this; } inline AdjacMatrix &zeroize() { memset(d, 0, sizeof(char)*n*n); return *this; } inline AdjacMatrix &free() { delete[] d; return *this; } inline char *operator[](int i) { return d + i*n; } inline const char *operator[](int i) const { return d + i*n; } inline AdjacMatrix &scann(FILE *file = stdin) { fscanf(file, "%i", &n); init(); scan(file); return *this; } AdjacMatrix &scan(FILE *file = stdin) { int input; for(auto *b = d, *e = d+n*n; b != e; ++b) fscanf(file, "%i", &input), *b = input; return *this; } AdjacMatrix &scan_riblist(FILE *file = stdin, bool oriented = false) { int m; fscanf(file, "%i%i", &n, &m); init(); zeroize(); int first, second; for(int i = 0; i < m; ++i) { fscanf(file, "%i%i", &first, &second); d[ n*first + second ] = 1; if(!oriented) d[ n*second + first ] = 1; } return *this; } AdjacMatrix &scan_riblist1(FILE *file = stdin, bool oriented = false) { int m; fscanf(file, "%i%i", &n, &m); init(); zeroize(); int first, second; for(int i = 0; i < m; ++i) { fscanf(file, "%i%i", &first, &second); --first, --second; d[ n*first + second ] = 1; if(!oriented) d[ n*second + first ] = 1; } return *this; } void print(FILE *file = stdout) const { fprintf(file, "%i\n", n); for(int i = 0; i < n; ++i) { for(int j = 0; j < n; ++j) { fprintf(file, "%i ", (int)d[i*n + j]); } fprintf(file, "\n"); } return; } }; using namespace std; char const *INPUT_FILE_NAME = "INPUT.TXT"; char const *OUTPUT_FILE_NAME = "OUTPUT.TXT"; int main( int argc, char *argv[] ) { AdjacMatrix adjm; { auto file = fopen(INPUT_FILE_NAME, "r"); adjm.scan_riblist1(file); fclose(file); } bool res = true; int val; for(int i = 0; i < adjm.n; ++i) { val = quix::summation(adjm[i], adjm[i+1]); if(val != adjm.n-1) { res = false; break; } } { auto file = fopen(OUTPUT_FILE_NAME, "w"); if(res) fprintf(file, "YES\n"); else fprintf(file, "NO\n"); } return 0; } 
