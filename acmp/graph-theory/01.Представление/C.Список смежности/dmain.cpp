#include <iostream>
 
#include <algorithm>
#include <vector>
struct AdjacList { std::vector< std::vector<int> > ribs; inline int n() const { return (int)ribs.size(); } inline AdjacList &clear() { ribs.clear(); return *this; } inline AdjacList &sort() { for(auto b = ribs.begin(), e = ribs.end(); b != e; ++b) std::sort( b->begin(), b->end() ); return *this; } inline std::vector<int> &operator[](int i) { return ribs[i]; } inline std::vector<int> const &operator[](int i) const { return ribs[i]; } AdjacList &scan(FILE *file = stdin) { int n; fscanf(file, "%i", &n); ribs.resize(n); int m; for(auto b = ribs.begin(), e = ribs.end(); b != e; ++b) { fscanf(file, "%i", &m); b->resize(m); for(auto bb = b->begin(), ee = b->end(); bb != ee; ++bb) fscanf(file, "%i", bb.base()); } return *this; } AdjacList &scan1(FILE *file = stdin) { int n; fscanf(file, "%i", &n); ribs.resize(n); int m; for(auto b = ribs.begin(), e = ribs.end(); b != e; ++b) { fscanf(file, "%i", &m); b->resize(m); for(auto bb = b->begin(), ee = b->end(); bb != ee; ++bb) fscanf(file, "%i", bb.base()), --*bb; } return *this; } AdjacList &scan_riblist(FILE *file = stdin, bool oriented = false){ int n, m; fscanf(file, "%i%i", &n, &m); ribs.resize(n); int first, second; for(int i = 0; i < m; ++i) { fscanf(file, "%i%i", &first, &second); ribs[first].push_back(second); if(!oriented) ribs[second].push_back(first); } return *this; } AdjacList &scan_riblist1(FILE *file = stdin, bool oriented = false){ int n, m; fscanf(file, "%i%i", &n, &m); ribs.resize(n); int first, second; for(int i = 0; i < m; ++i) { fscanf(file, "%i%i", &first, &second); --first, --second; ribs[first].push_back(second); if(!oriented) ribs[second].push_back(first); } return *this; } void print(FILE *file = stdout) const { fprintf(file, "%i\n", (int)n()); for(auto b = ribs.begin(), e = ribs.end(); b != e; ++b) { fprintf(file, "%i ", (int)b->size()); for(auto bb = b->begin(), ee = b->end(); bb != ee; ++bb) { fprintf(file, "%i ", *bb); } fprintf(file, "\n"); } return; } void print1(FILE *file = stdout) const { fprintf(file, "%i\n", (int)n()); for(auto b = ribs.begin(), e = ribs.end(); b != e; ++b) { fprintf(file, "%i ", (int)b->size()); for(auto bb = b->begin(), ee = b->end(); bb != ee; ++bb) { fprintf(file, "%i ", *bb+1); } fprintf(file, "\n"); } return; } };  
#include <cstring>
struct AdjacMatrix { int n; char *d; inline AdjacMatrix &init() { d = new char[n*n]; return *this; } inline AdjacMatrix &init(int newn) { n = newn; d = new char[n*n]; return *this; } inline AdjacMatrix &zeroize() { memset(d, 0, sizeof(char)*n*n); return *this; } inline AdjacMatrix &free() { delete[] d; return *this; } inline char *operator[](int i) { return d + i*n; } inline const char *operator[](int i) const { return d + i*n; } inline AdjacMatrix &scann(FILE *file = stdin) { fscanf(file, "%i", &n); init(); scan(file); return *this; } AdjacMatrix &scan(FILE *file = stdin) { int input; for(auto *b = d, *e = d+n*n; b != e; ++b) fscanf(file, "%i", &input), *b = input; return *this; } void print(FILE *file = stdout) const { fprintf(file, "%i\n", n); for(int i = 0; i < n; ++i) { for(int j = 0; j < n; ++j) { fprintf(file, "%i ", (int)d[i*n + j]); } fprintf(file, "\n"); } return; } };  void conv(AdjacMatrix const &adjm, AdjacList &adjl) { adjl.ribs.resize(adjm.n); for(int i = 0; i < adjm.n; ++i) { for(int j = 0; j < adjm.n; ++j) { if(adjm[i][j]) adjl[i].push_back(j); } } return; } void conv(AdjacList const &adjl, AdjacMatrix &adjm) { adjm.init( adjl.n() ).zeroize(); for(int i = 0; i < adjl.n(); ++i) { for(auto b = adjl[i].begin(), e = adjl[i].end(); b != e; ++b) adjm[i][*b] = 1; } return; } using namespace std; char const *INPUT_FILE_NAME = "INPUT.TXT"; char const *OUTPUT_FILE_NAME = "OUTPUT.TXT"; int main( int argc, char *argv[] ) { AdjacList adjl; AdjacMatrix adjm; FILE *file; file = fopen(INPUT_FILE_NAME, "r"); adjl.scan1(file); fclose(file); conv(adjl, adjm); file = fopen(OUTPUT_FILE_NAME, "w"); adjm.print(file); fclose(file); return 0; } 
