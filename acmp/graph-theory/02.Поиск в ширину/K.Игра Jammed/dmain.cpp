#include <iostream>
#include <fstream>
#include <queue>
#include <set>
#include <cmath>
#include <type_traits>
#include <utility>
#include <array>
#include <list>
#include <tuple>
#include <vector>
namespace quix { template<class Ostream, typename T> inline Ostream &print(Ostream &os, T const &t) { os << t; return os; } template<class Ostream, typename T> inline Ostream &print(Ostream &os, T* t) { os << '&' << *t; return os; } template<class Ostream, typename T, typename U> inline Ostream &print( Ostream &os, std::pair<T, U> const &pair, std::string const &term = ", " ) { print( print( os << "< ", pair.first ) << term, pair.second ) << " >"; return os; } template<class Ostream, typename T> Ostream &print( Ostream &os, std::vector<T> const &vec, std::string const &term = ", " ) { os << "< "; if(!vec.empty()) { print(os, vec.front()); for(auto b = vec.begin()+1, e = vec.end(); b != e; ++b) { print(os << term, *b); } } os << " >"; return os; } template<class Ostream, typename T> Ostream &print( Ostream &os, std::list<T> const &l, std::string const &term = ", " ) { os << "[ "; if(!l.empty()) { print(os, l.front()); for(auto b = std::next(l.begin()), e = l.end(); b != e; ++b) { print(os << term, *b); } } os << " ]"; return os; }  template<class Ostream, typename Iterator> Ostream &print( Ostream &os, Iterator b, Iterator e, std::string const &term = ", " ) { if(b == e) return os; os << *b; while(++b != e) os << term << *b; } template<class Ostream, typename T, size_t N> Ostream &print( Ostream &os, std::array<T, N> const &arr, std::string const &term = ", " ) { static_assert(N > 0); os << "( " << arr[0]; for(size_t i = 1; i < N; ++i) { print(os << term, arr[i]); } os << " )"; return os; } template<class Ostream, typename T, typename SizeType = int> Ostream &print( Ostream &os, T const *arr, SizeType len, std::string const &term = ", " ) { if(!len) return os << "( )"; T const *end = arr+len; os << "( " << *arr; while(++arr != end) os << term << *arr; return os << " )"; } template<class Ostream, class Matrix> Ostream &print_matrix( Ostream &os, Matrix const &m, unsigned int w, unsigned int h, std::string const &elterm = "\t", std::string const &lineterm = "\n" ) { for(unsigned int i = 0; i < h; ++i) { for(unsigned int j = 0; j < w; ++j) { print(os, m[i][j]) << elterm; } os << lineterm; } return os; } template<class Ostream, int n, int max, typename...Args> struct PRINT_TUPLE { static Ostream &print( Ostream &os, std::tuple<Args...> const &tuple ) { os << std::get<n-1>(tuple) << ", "; return PRINT_TUPLE<Ostream, n+1, max, Args...>::print(os, tuple); } }; template<class Ostream, int max, typename...Args> struct PRINT_TUPLE<Ostream, max, max, Args...> { static Ostream &print( Ostream &os, std::tuple<Args...> const &tuple ) { return os << std::get<max-1>(tuple); } }; template<class Ostream, typename...Args> Ostream &print( Ostream &os, std::tuple<Args...> const &tuple ) { os << "[ "; quix::PRINT_TUPLE< Ostream, 1, sizeof...(Args), Args... >::print(os, tuple); os << " ]"; return os; } template<class Istream, typename T> Istream &scan( Istream &is, std::vector<T> &vec ) { T input; while(is >> input) vec.push_back(input); return is; } template<class Istream, typename T> Istream &scan( Istream &is, T *arr, int size = -1, int *n = nullptr ) { int i = 0; for(; i != size && is >> *arr; ++i, ++arr); if(n) *n = i; return is; } template<class Istream, typename T> Istream &scan( Istream &is, T *arr, T *arrend, int *n = nullptr ) { int an = 0; while(arr != arrend && is >> *arr) { ++arr; ++an; } if(n) *n = an; return is; } template<class Ostream> inline Ostream &writestr( Ostream &os, std::string const &str ) { int size = str.size(); os.write( (char const *)&size, sizeof size ); os.write( str.c_str(), sizeof(char)*size ); return os; } template<class Istream> inline Istream &readstr( Istream &is, std::string &str ) { int size = 0; is.read( (char *)&size, sizeof size ); str.resize( size ); is.read( const_cast<char*>(str.data()), sizeof(char)*size ); return is; } } template<class Ostream, typename T> inline Ostream &operator<<(Ostream &os, std::vector<T> const &vec) { return quix::print(os, vec); } template<class Istream, typename T> inline Istream &operator>>(Istream &is, std::vector<T> &vec) { return quix::scan(is, vec); } template<class Ostream, typename T> inline Ostream &operator<<(Ostream &os, std::list<T> const &l) { return quix::print(os, l); } template<class Ostream, typename T, typename U> inline Ostream &operator<<(Ostream &os, std::pair<T, U> const &pair) { return quix::print(os, pair); } template<class Ostream, typename T, size_t N> inline Ostream &operator<<(Ostream &os, std::array<T, N> const &arr) { return quix::print(os, arr); } template<class Ostream, typename...Args> inline Ostream &operator<<( Ostream &os, std::tuple<Args...> const &tuple ) { return quix::print(os, tuple); } namespace quix { typedef long long llong; typedef long double ldouble; template<typename T> struct Type { typedef T value; }; template<bool Cond, typename T, typename U> struct IF { typedef T value_type; }; template<typename T, typename U> struct IF<false, T, U> { typedef U value_type; };  template<typename F, typename T, typename U> inline auto bcascade(F f, T t, U u) { return f(t, u); } template<typename F, typename T, typename...Args> inline auto bcascade(F f, T t, Args...args) { return f(t, bcascade(f, args...)); } template<typename F, typename T> inline void ucascade(F f, T t) { f(t); return; } template<typename F, typename T, typename...Args> inline void ucascade(F f, T t, Args...args) { f(t); ucascade(f, args...); return; } template<typename F, typename F2, typename T, typename U> inline T dcascade(F f, F2 f2, T t, U u) { return f(f2(t), f2(u)); } template<typename F, typename F2, typename T, typename...Args> inline T dcascade(F f, F2 f2, T t, Args...args) { return f( f2(t), f2(dcascade(f, f2, args...)) ); } } namespace quix { template<typename T> struct Point { typedef T value_type; value_type x, y; template<class P> Point &operator=(P const &p) { x = p.x; y = p.y; return *this; } template<class P> inline operator P() const { P p; p.x = x; p.y = y; return p; } template<typename U> inline operator std::pair<U, U>() const { return std::pair<U, U>(x, y); } template<class P> inline P to() const { P p; p.x = x; p.y = y; return p; } template<typename U = value_type> inline std::pair<U, U> topair() const { return std::pair<U, U>{ x, y }; } inline double length() const { return std::hypot(x, y); } inline double hypot() const { return std::hypot(x, y); } template<typename P> inline double dis(P const &p) const { return std::hypot(p.x-x, p.y-y); } template<class Ostream> Ostream &print( Ostream &os ) const { os << "("; quix::print(os, x) << ", "; quix::print(os, y) << ")"; return os; } }; template<typename T, typename U> inline bool operator==( Point<T> const &lhs, Point<U> const &rhs ) { return lhs.x == rhs.x && lhs.y == rhs.y; } template<typename T, typename U> inline bool operator<( Point<T> const &lhs, Point<U> const &rhs ) { return lhs.y != rhs.y ? lhs.y < rhs.y : lhs.x < rhs.x; } template<typename T, typename U> inline bool operator>( Point<T> const &lhs, Point<U> const &rhs ) { return lhs.y != rhs.y ? lhs.y > rhs.y : lhs.x > rhs.x; } template<typename T, typename U> inline bool operator<=( Point<T> const &lhs, Point<U> const &rhs ) { return !(lhs > rhs); } template<typename T, typename U> inline bool operator>=( Point<T> const &lhs, Point<U> const &rhs ) { return !(lhs < rhs); } template<typename T, typename U> inline Point<decltype(T()+U())> operator+( Point<T> const &lhs, U rhs ) { return {lhs.x+rhs, lhs.y+rhs}; } template<typename T, typename U> inline Point<decltype(T()-U())> operator-( Point<T> const &lhs, U rhs ) { return {lhs.x-rhs, lhs.y-rhs}; } template<typename T, typename U> inline Point<decltype(T()*U())> operator*( Point<T> const &lhs, U rhs ) { return {lhs.x*rhs, lhs.y*rhs}; } template<typename T, typename U> inline Point<decltype(T()/U())> operator/( Point<T> const &lhs, U rhs ) { return { lhs.x/rhs, lhs.y/rhs }; } template<typename T, typename U> inline Point<decltype(T()+U())> operator+( Point<T> const &lhs, Point<U> const &rhs ) { return {lhs.x+rhs.x, lhs.y+rhs.y}; } template<typename T, typename U> inline Point<decltype(T()-U())> operator-( Point<T> const &lhs, Point<U> const &rhs ) { return {lhs.x-rhs.x, lhs.y-rhs.y}; } template<typename T, typename U> inline Point<decltype(T()*U())> operator*( Point<T> const &lhs, Point<U> const &rhs ) { return {lhs.x*rhs.x, lhs.y*rhs.y}; } template<typename T, typename U> inline Point<decltype(T()/U())> operator/( Point<T> const &lhs, Point<U> const &rhs ) { return {lhs.x/rhs.x, lhs.y/rhs.y}; } template<typename T, typename U> inline Point<T> &operator+=( Point<T> &lhs, U rhs ) { lhs.x += rhs; lhs.y += rhs; return lhs; } template<typename T, typename U> inline Point<T> &operator-=( Point<T> &lhs, U rhs ) { lhs.x -= rhs; lhs.y -= rhs; return lhs; } template<typename T, typename U> inline Point<T> &operator*=( Point<T> &lhs, U rhs ) { lhs.x *= rhs; lhs.y *= rhs; return lhs; } template<typename T, typename U> inline Point<T> &operator/=( Point<T> &lhs, U rhs ) { lhs.x /= rhs; lhs.y /= rhs; return lhs; } template<typename T, typename U> inline Point<T> &operator+=( Point<T> &lhs, Point<U> const &rhs ) { lhs.x += rhs.x; lhs.y += rhs.y; return lhs; } template<typename T, typename U> inline Point<T> &operator-=( Point<T> &lhs, Point<U> const &rhs ) { lhs.x -= rhs.x; lhs.y -= rhs.y; return lhs; } template<typename T, typename U> inline Point<T> &operator*=( Point<T> &lhs, Point<U> const &rhs ) { lhs.x *= rhs.x; lhs.y *= rhs.y; return lhs; } template<typename T, typename U> inline Point<T> &operator/=( Point<T> &lhs, Point<U> const &rhs ) { lhs.x /= rhs.x; lhs.y /= rhs.y; return lhs; } template<class Ostream, typename T> inline Ostream &operator<<( Ostream &os, Point<T> const &toprint  ) { return toprint.print(os); } template<typename T = void, class C> inline auto makep(C const &from) { Point< typename IF< std::is_same<T, void>::value, decltype(C::x), T >::value_type > p; p.x = from.x; p.y = from.y; return p; } template<typename T = void, typename U> inline auto makep(U x, U y) { Point< typename IF< std::is_same<T, void>::value, U, T >::value_type > p; p.x = x; p.y = y; return p; } template<typename T = void, typename U> inline auto makep(std::pair<U, U> const &pair) { Point< typename IF< std::is_same<T, void>::value, U, T >::value_type > p; p.x = pair.first; p.y = pair.second; return p; } typedef Point<char> PointC; typedef Point<int> PointI; typedef Point<unsigned> PointU; typedef Point<float> PointF; typedef Point<double> PointD; } using namespace std; using namespace quix; char const *INPUT_FILE_NAME = "INPUT.TXT"; char const *OUTPUT_FILE_NAME = "OUTPUT.TXT"; inline bool isvalid(PointI p) { return p.x >= 0 && p.x < 4 && p.y >= 0 && p.y < 2; } inline char &at(string &s, PointI p) { return s[ p.y*4 + p.x ]; } int main( int argc, char *argv[] ) { struct Stage { string s; int c = 0; }; static constexpr PointI const OFFSET[4] = { { 1, 0 }, { -1, 0 }, { 0, 1 }, { 0, -1 } }; string begin, end; { string input; ifstream fin(INPUT_FILE_NAME); fin >> begin >> input; begin += input; fin >> end >> input; end += input; } set<string> set; set.insert(begin); queue<Stage> que; que.push({begin, 0}); Stage st; int pos; PointI cur, p; int res = -1; while(!que.empty()) { st = que.front(); que.pop(); if(st.s == end) { res = st.c; break; } pos = (int)st.s.find('#'); cur.x = pos%4, cur.y = pos/4; for(auto off : OFFSET) { p = cur + off; if(!isvalid(p)) continue; swap(at(st.s, p), at(st.s, cur)); if( set.insert(st.s).second ) que.push( { st.s, st.c+1 } ); swap(at(st.s, p), at(st.s, cur)); } } ofstream(OUTPUT_FILE_NAME) << res << endl; return 0; } 
