#include <iostream>
#include <vector>


// макрос, который берёт модуль

#define MOD(x) ( (x) % 1000000007 )


using namespace std;





// main
int main( int argc, char *argv[] )
{
	typedef long long llong;

	// размеры нашего поля
	int n, m;
	// кол-во опасностей
	int dang;
	
	
	
	// input
	scanf("%i%i%i", &n, &m, &dang);
	/*
	 * так как поле должно включать клетку
	 * с координатами n m
	 */
	++n, ++m;
	// наше поле
	vector< vector<llong> > f(n, vector<llong>(m, 0));

	// помечаем опасные клетки
	for(int i = 0, x, y; i < dang; ++i)
		scanf("%i%i", &x, &y),
		f[y][x] = -1;
	
	
	
	// solve
	/*
	 * в самую первую клетку мы можем
	 * добраться единственным способом:
	 * стоять
	 */
	f[0][0] = 1;
	/*
	 * проходимся по всем клеткам:
	 * сначала первая строка и в ней
	 * каждая клетка, затем следующая
	 * строка
	 */
	for(int y = 0; y < n; ++y)
	for(int x = 0; x < m; ++x)
	{
		/*
		 * если это опасная клетка, мы в неё
		 * добраться никак не можем, поэтому
		 * устанавливаем ноль
		 */
		if(f[y][x] < 0)
		{
			f[y][x] = 0;
			continue;
		}

		/*
		 * мы можем добраться до текущей
		 * клетки либо сверху либо слева:
		 * суммируем варианты добраться до
		 * соответствующих клеток (не забываем
		 * проверять, существует ли вообще
		 * такая клетка)
		 */
		if(x > 0)
			f[y][x] += f[y][x-1];
		if(y > 0)
			f[y][x] += f[y-1][x];

		/*
		 * значения могут быть очень большими,
		 * поэтому берём модуль
		 */
		f[y][x] = MOD(f[y][x]);
	}
	
	
	
	// output
	/*
	 * выводи, как добраться до
	 * клетки n m (изначальных,
	 * когда мы ещё не прибавили к ним
	 * единицу)
	 */
	printf("%lli\n", f[n-1][m-1]);



	return 0;
}





// end
